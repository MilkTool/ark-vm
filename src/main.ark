[c] func printf(fmt: str, ...): int;

PSH: s32 = 0;
ADD: s32 = 1;
SUB: s32 = 2;
POP: s32 = 3;
HLT: s32 = 4;

struct VirtualMachine {
    running: bool,
    sp: s32,
    ip: s32,
    program: []s32,
    stack: []s32,
}

func fetch(vm: ^VirtualMachine): s32 {
    instr: s32 = vm.program[vm.ip];
    return instr;
}

func eval(vm: ^VirtualMachine, instr: s32) {
    if instr == HLT {
        vm.running = false;
    }
    else if instr == PSH {
        vm.ip = vm.ip + 1;
        vm.sp = vm.sp + 1;
        C::printf("PSH sp: %d\n", vm.sp);
        vm.stack[vm.sp] = vm.program[vm.ip];
    }
    else if instr == POP {
        val := vm.stack[vm.sp];
        vm.sp = vm.sp - 1;
        C::printf("POP result: %d\n", val);
    }
    else if instr == ADD {
        a := vm.stack[vm.sp];
        vm.sp = vm.sp - 1;

        b := vm.stack[vm.sp];
        vm.sp = vm.sp - 1;

        result := a + b;
        C::printf("ADD result: %d\n", result);
        vm.sp = vm.sp + 1;
        vm.stack[vm.sp] = result;
    }
    else if instr == SUB {
            a := vm.stack[vm.sp];
            vm.sp = vm.sp - 1;

            b := vm.stack[vm.sp];
            vm.sp = vm.sp - 1;

            result := b - a;
            C::printf("SUB result: %d\n", result);
            vm.sp = vm.sp + 1;
            vm.stack[vm.sp] = result;
    }
    else {
        C::printf("unimplemented instr\n");
        ^(^int(0)) = 0; // cause a segfault
    }
}

func main(): int {
    vm: VirtualMachine;
    vm.running = true;
    vm.program = [ PSH, 5, PSH, 5, ADD, PSH, 7, SUB, POP, HLT ];
    vm.ip = 0;
    vm.sp = 0;
    vm.stack = [ 0, 0, 0, 0, 0 ];

    for vm.running {
        eval(&vm, fetch(&vm));
        vm.ip = vm.ip + 1;
    }

    return 0;
}
